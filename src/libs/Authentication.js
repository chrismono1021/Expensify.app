import requireParameters from './requireParameters';
import * as Network from './Network';
import * as NetworkStore from './Network/NetworkStore';
import * as NetworkEvents from './Network/NetworkEvents';
import updateSessionAuthTokens from './actions/Session/updateSessionAuthTokens';
import CONFIG from '../CONFIG';
import redirectToSignIn from './actions/SignInRedirect';
import CONST from '../CONST';
import Log from './Log';

/**
 * @param {Object} parameters
 * @param {Boolean} [parameters.useExpensifyLogin]
 * @param {String} parameters.partnerName
 * @param {String} parameters.partnerPassword
 * @param {String} parameters.partnerUserID
 * @param {String} parameters.partnerUserSecret
 * @param {String} [parameters.twoFactorAuthCode]
 * @param {String} [parameters.email]
 * @param {String} [parameters.authToken]
 * @returns {Promise}
 */
function Authenticate(parameters) {
    const commandName = 'Authenticate';

    requireParameters([
        'partnerName',
        'partnerPassword',
        'partnerUserID',
        'partnerUserSecret',
    ], parameters, commandName);

    return Network.post(commandName, {
        // When authenticating for the first time, we pass useExpensifyLogin as true so we check
        // for credentials for the expensify partnerID to let users Authenticate with their expensify user
        // and password.
        useExpensifyLogin: parameters.useExpensifyLogin,
        partnerName: parameters.partnerName,
        partnerPassword: parameters.partnerPassword,
        partnerUserID: parameters.partnerUserID,
        partnerUserSecret: parameters.partnerUserSecret,
        twoFactorAuthCode: parameters.twoFactorAuthCode,
        authToken: parameters.authToken,
        shouldRetry: false,

        // Force this request to be made because the network queue is paused when re-authentication is happening
        forceNetworkRequest: true,

        // Add email param so the first Authenticate request is logged on the server w/ this email
        email: parameters.email,
    })
        .then((response) => {
            // If we didn't get a 200 response from Authenticate we either failed to Authenticate with
            // an expensify login or the login credentials we created after the initial authentication.
            // In both cases, we need the user to sign in again with their expensify credentials
            if (response.jsonCode !== 200) {
                switch (response.jsonCode) {
                    case 401:
                        throw new Error('passwordForm.error.incorrectLoginOrPassword');
                    case 402:
                        // If too few characters are passed as the password, the WAF will pass it to the API as an empty
                        // string, which results in a 402 error from Auth.
                        if (response.message === '402 Missing partnerUserSecret') {
                            throw new Error('passwordForm.error.incorrectLoginOrPassword');
                        }
                        throw new Error('passwordForm.error.twoFactorAuthenticationEnabled');
                    case 403:
                        if (response.message === 'Invalid code') {
                            throw new Error('passwordForm.error.incorrect2fa');
                        }
                        throw new Error('passwordForm.error.invalidLoginOrPassword');
                    case 404:
                        throw new Error('passwordForm.error.unableToResetPassword');
                    case 405:
                        throw new Error('passwordForm.error.noAccess');
                    case 413:
                        throw new Error('passwordForm.error.accountLocked');
                    default:
                        throw new Error('passwordForm.error.fallback');
                }
            }
            return response;
        });
}

/**
 * Reauthenticate using the stored credentials and redirect to the sign in page if unable to do so.
 *
 * @param {String} [command] command name for loggin purposes
 * @returns {Promise}
 */
function reauthenticate(command = '') {
    // Prevent any more requests from being processed while authentication happens
    NetworkStore.setIsAuthenticating(true);

    const credentials = NetworkStore.getCredentials();
    return Authenticate({
        useExpensifyLogin: false,
        partnerName: CONFIG.EXPENSIFY.PARTNER_NAME,
        partnerPassword: CONFIG.EXPENSIFY.PARTNER_PASSWORD,
        partnerUserID: credentials.autoGeneratedLogin,
        partnerUserSecret: credentials.autoGeneratedPassword,
    })
        .then((response) => {
            // If authentication fails throw so that we hit
            // the catch below and redirect to sign in
            if (response.jsonCode !== 200) {
                throw new Error(response.message);
            }

            // Update authToken in Onyx and in our local variables so that API requests will use the
            // new authToken
            updateSessionAuthTokens(response.authToken, response.encryptedAuthToken);

            // Note: It is important to manually set the authToken that is in the store here since any requests that are hooked into
            // reauthenticate .then() will immediate post and use the local authToken. Onyx updates subscribers lately so it is not
            // enough to do the updateSessionAuthTokens() call above.
            NetworkStore.setAuthToken(response.authToken);

            // The authentication process is finished so the network can be unpaused to continue
            // processing requests
            NetworkStore.setIsAuthenticating(false);
        })

        .catch((error) => {
            // If authentication fails, then the network can be unpaused
            NetworkStore.setIsAuthenticating(false);

            // When a fetch() fails and the "API is offline" error is thrown we won't log the user out. Most likely they
            // have a spotty connection and will need to try to reauthenticate when they come back online. We will
            // re-throw this error so it can be handled by callers of reauthenticate().
            if (error.message === CONST.ERROR.API_OFFLINE) {
                throw error;
            }

            // If we experience something other than a network error then redirect the user to sign in
            redirectToSignIn(error.message);

            Log.hmmm('Redirecting to Sign In because we failed to reauthenticate', {
                command,
                error: error.message,
            });
        });
}

// When an authToken expires we handle it from inside API so we can access the reauthenticate method
NetworkEvents.onAuthTokenExpired((commandName, onSuccess, onFailure) => {
    reauthenticate(commandName)
        .then(onSuccess)
        .catch(onFailure);
});

/**
 * Reauthentication middleware
 *
 * @param {Promise} requestPromise
 * @returns {Promise}
 */
function reauthenticateAndRetry(requestPromise) {
    return requestPromise
        .then((response) => {
            return response;
        })
        .catch((error) => {
            throw error;
        });
}

export {
    reauthenticate,
    Authenticate,
    reauthenticateAndRetry,
};
