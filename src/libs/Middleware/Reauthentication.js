import lodashGet from 'lodash/get';
import CONST from '../../CONST';
import * as NetworkStore from '../Network/NetworkStore';
import * as MainQueue from '../Network/MainQueue';
import * as Authentication from '../Authentication';
import * as AuthenticationUtils from '../AuthenticationUtils';
import * as PersistedRequests from '../actions/PersistedRequests';
import * as Request from '../Request';

/**
 * Reauthentication middleware
 *
 * @param {Promise} response
 * @param {Object} request
 * @param {Boolean} isFromSequentialQueue
 * @returns {Promise}
 */
function Reauthentication(response, request, isFromSequentialQueue) {
    return response
        .then((data) => {
            if (NetworkStore.getIsOffline()) {
                // If we are offline and somehow handling this response we do not want to reauthenticate
                throw new Error('Unable to reauthenticate because we are offline');
            }

            if (data.jsonCode === CONST.JSON_CODE.NOT_AUTHENTICATED) {
                const credentials = AuthenticationUtils.getCredentials();

                // Credentials haven't been initialized. We will not be able to re-authenticate with the API.
                const unableToReauthenticate = (!credentials || !credentials.autoGeneratedLogin || !credentials.autoGeneratedPassword);
                if (unableToReauthenticate) {
                    if (isFromSequentialQueue) {
                        throw new Error('Missing credentials required for authentication');
                    }

                    MainQueue.replay(request);
                    return;
                }

                // There are some API requests that should not be retried when there is an auth failure like
                // creating and deleting logins. In those cases, they should handle the original response instead
                // of the new response created by handleExpiredAuthToken.
                const shouldRetry = lodashGet(request, 'data.shouldRetry');
                if (!shouldRetry) {
                    if (isFromSequentialQueue) {
                        return data;
                    }

                    request.resolve(data);
                    return;
                }

                // We are already authenticating
                if (AuthenticationUtils.isAuthenticating()) {
                    if (isFromSequentialQueue) {
                        // This should not be possible in theory. If we go offline while we are Authenticating or handling a response with a 407 jsonCode then isAuthenticating should be
                        // set to false. If it does then we will throw an error so the request can be retried.
                        throw new Error('Cannot complete sequential request because we are already authenticating');
                    }

                    MainQueue.replay(request);
                    return data;
                }

                return Authentication.reauthenticate(request.commandName)
                    .then((authenticateResponse) => {
                        if (isFromSequentialQueue) {
                            return Request.process(request, true);
                        }

                        MainQueue.replay(request);
                        return authenticateResponse;
                    })
                    .catch(() => {
                        if (isFromSequentialQueue) {
                            throw new Error('Unable to reauthenticate sequential queue request because we failed to reauthenticate');
                        }

                        // If we make it here, then our reauthenticate request could not be made due to a networking issue. The original request can be retried safely.
                        MainQueue.replay(request);
                    });
            }

            if (isFromSequentialQueue) {
                PersistedRequests.remove(request);
                return data;
            }

            request.resolve(data);
        });
}

export default Reauthentication;
